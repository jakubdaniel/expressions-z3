-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Encode and Decode expressions from Z3 ASTs
--   
--   A simple interface for converting expressions back and forth between
--   pure representation and an AST within a Z3 context.
--   
--   Assume
--   
--   <pre>
--   λ&gt; :m + Control.Monad Data.Expression Data.Expression.Z3 Z3.Monad Data.Singletons
--   λ&gt; :t f
--   f :: MonadZ3 z3 =&gt; AST -&gt; z3 AST
--   </pre>
--   
--   Then
--   
--   <pre>
--   λ&gt; let g :: ( MonadZ3 z3, IFromZ3 f, IToZ3 f, SingI s ) =&gt; IFix f s -&gt; z3 (IFix f s); g = fromZ3 &lt;=&lt; f &lt;=&lt; toZ3
--   λ&gt; :t g (var "a" :: Lia 'BooleanSort)
--   g (var "a" :: Lia 'BooleanSort) :: MonadZ3 z3 =&gt; z3 (Lia 'BooleanSort)
--   </pre>
--   
--   For example
--   
--   <pre>
--   λ&gt; let f b = mkStringSymbol "a" &gt;&gt;= mkIntVar &gt;&gt;= toApp &gt;&gt;= \a' -&gt; mkForallConst [] [a'] b
--   λ&gt; let g :: ( MonadZ3 z3, IFromZ3 f, IToZ3 f ) =&gt; IFix f 'BooleanSort -&gt; z3 (IFix f 'BooleanSort); g = fromZ3 &lt;=&lt; g &lt;=&lt; toZ3
--   λ&gt; evalZ3 $ g (var "a" .+. cnst 1 .=. var "b" :: Lia 'BooleanSort)
--   (forall ((a : int)) (= (+ 1 (a : int)) (b : int)))
--   </pre>
--   
--   Or more interestingly
--   
--   <pre>
--   λ&gt; :{
--   |  let f :: ( MonadZ3 z3, IFromZ3 f, IToZ3 f, SingI s ) =&gt; IFix f s -&gt; z3 (IFix f s)
--   |      f a = do
--   |      a' &lt;- toZ3 a
--   |      r &lt;- getModel
--   |      case r of
--   |          (Sat, Just m) -&gt; do
--   |              v &lt;- modelEval m a' True
--   |              case v of
--   |                Just v' -&gt; fromZ3 v'
--   |                _ -&gt; error "..."
--   |          _ -&gt; error "..."
--   :}
--   λ&gt; evalZ3 $ f (var "a" :: Lia 'BooleanSort)
--   false
--   λ&gt; evalZ3 $ f (var "a" :: Lia 'IntegralSort)
--   0
--   λ&gt; evalZ3 $ f (var "a" .+. cnst 1:: Lia 'IntegralSort)
--   1
--   </pre>
@package expressions-z3
@version 0.4

module Data.Expression.Z3
class IFunctor f => IToZ3 f
toZ3 :: forall f (s :: Sort) z3. (IToZ3 f, MonadZ3 z3) => IFix f s -> z3 AST
class IFromZ3Into f f => IFromZ3 f
fromZ3 :: forall (f :: (Sort -> *) -> Sort -> *) (s :: Sort) z3. (IFromZ3 f, MonadZ3 z3, SingI s) => AST -> z3 (IFix f s)
assert :: forall (f :: (Sort -> *) -> Sort -> *) z3. (IToZ3 f, MonadZ3 z3) => IFix f  'BooleanSort -> z3 ()
model :: forall (f :: (Sort -> *) -> Sort -> *) (s :: Sort) z3. (IToZ3 f, IFromZ3 f, IShow f, MonadZ3 z3, SingI s) => IFix f s -> z3 (IFix f s)
unsatcore :: forall (f :: (Sort -> *) -> Sort -> *) z3. (IToZ3 f, MonadZ3 z3) => [IFix f  'BooleanSort] -> z3 [IFix f  'BooleanSort]
interpolate :: forall (f :: (Sort -> *) -> Sort -> *) z3. (IToZ3 f, IFromZ3 f, MonadZ3 z3) => [IFix f  'BooleanSort] -> z3 [IFix f  'BooleanSort]
eliminate :: forall (f :: (Sort -> *) -> Sort -> *) z3. (IToZ3 f, IFromZ3 f, MonadZ3 z3) => IFix f  'BooleanSort -> z3 (IFix f  'BooleanSort)

-- | Run a query and restore the initial logical context.
--   
--   This is a shorthand for <a>push</a>, run the query, and <a>pop</a>.
local :: MonadZ3 z3 => z3 a -> z3 a

-- | Create a backtracking point.
--   
--   For <tt>push; m; pop 1</tt> see <a>local</a>.
push :: MonadZ3 z3 => z3 ()

-- | Backtrack <i>n</i> backtracking points.
--   
--   Contrary to <a>solverPop</a> this funtion checks whether <i>n</i> is
--   within the size of the solver scope stack.
pop :: MonadZ3 z3 => Int -> z3 ()

-- | Check whether the given logical context is consistent or not.
check :: MonadZ3 z3 => z3 Result

-- | Result of a satisfiability check.
--   
--   This corresponds to the <i>z3_lbool</i> type in the C API.
data Result
Sat :: Result
Unsat :: Result
Undef :: Result
instance Control.Monad.IO.Class.MonadIO a => Control.Monad.IO.Class.MonadIO (Data.Expression.Z3.Decoder g a)
instance GHC.Base.Monad a => GHC.Base.Monad (Data.Expression.Z3.Decoder g a)
instance GHC.Base.Monad a => GHC.Base.Alternative (Data.Expression.Z3.Decoder g a)
instance GHC.Base.Monad a => GHC.Base.Applicative (Data.Expression.Z3.Decoder g a)
instance GHC.Base.Functor a => GHC.Base.Functor (Data.Expression.Z3.Decoder g a)
instance Data.Expression.Z3.IFromZ3 Data.Expression.VarF
instance Data.Expression.Z3.IFromZ3 Data.Expression.ConjunctionF
instance Data.Expression.Z3.IFromZ3 Data.Expression.DisjunctionF
instance Data.Expression.Z3.IFromZ3 Data.Expression.NegationF
instance Data.Singletons.Internal.SingI v => Data.Expression.Z3.IFromZ3 (Data.Expression.UniversalF v)
instance Data.Singletons.Internal.SingI v => Data.Expression.Z3.IFromZ3 (Data.Expression.ExistentialF v)
instance Data.Expression.Z3.IFromZ3 Data.Expression.Equality.EqualityF
instance Data.Expression.Z3.IFromZ3 Data.Expression.Arithmetic.ArithmeticF
instance Data.Expression.Z3.IFromZ3 Data.Expression.IfThenElse.IfThenElseF
instance Data.Expression.Z3.IFromZ3 Data.Expression.Array.ArrayF
instance (Data.Expression.Z3.IFromZ3Into f (f Data.Expression.Utils.Indexed.Sum.:+: g), Data.Expression.Z3.IFromZ3Into g (f Data.Expression.Utils.Indexed.Sum.:+: g)) => Data.Expression.Z3.IFromZ3 (f Data.Expression.Utils.Indexed.Sum.:+: g)
instance (Data.Expression.VarF Data.Expression.Utils.Indexed.Sum.:<: g) => Data.Expression.Z3.IFromZ3Into Data.Expression.VarF g
instance (Data.Expression.ConjunctionF Data.Expression.Utils.Indexed.Sum.:<: g) => Data.Expression.Z3.IFromZ3Into Data.Expression.ConjunctionF g
instance (Data.Expression.DisjunctionF Data.Expression.Utils.Indexed.Sum.:<: g) => Data.Expression.Z3.IFromZ3Into Data.Expression.DisjunctionF g
instance (Data.Expression.NegationF Data.Expression.Utils.Indexed.Sum.:<: g) => Data.Expression.Z3.IFromZ3Into Data.Expression.NegationF g
instance (Data.Expression.UniversalF v Data.Expression.Utils.Indexed.Sum.:<: g, Data.Singletons.Internal.SingI v) => Data.Expression.Z3.IFromZ3Into (Data.Expression.UniversalF v) g
instance (Data.Expression.ExistentialF v Data.Expression.Utils.Indexed.Sum.:<: g, Data.Singletons.Internal.SingI v) => Data.Expression.Z3.IFromZ3Into (Data.Expression.ExistentialF v) g
instance (Data.Expression.Equality.EqualityF Data.Expression.Utils.Indexed.Sum.:<: g) => Data.Expression.Z3.IFromZ3Into Data.Expression.Equality.EqualityF g
instance (Data.Expression.Arithmetic.ArithmeticF Data.Expression.Utils.Indexed.Sum.:<: g) => Data.Expression.Z3.IFromZ3Into Data.Expression.Arithmetic.ArithmeticF g
instance (Data.Expression.IfThenElse.IfThenElseF Data.Expression.Utils.Indexed.Sum.:<: g) => Data.Expression.Z3.IFromZ3Into Data.Expression.IfThenElse.IfThenElseF g
instance (Data.Expression.Array.ArrayF Data.Expression.Utils.Indexed.Sum.:<: g) => Data.Expression.Z3.IFromZ3Into Data.Expression.Array.ArrayF g
instance (Data.Expression.Z3.IFromZ3Into f h, Data.Expression.Z3.IFromZ3Into g h) => Data.Expression.Z3.IFromZ3Into (f Data.Expression.Utils.Indexed.Sum.:+: g) h
instance Data.Expression.Z3.IToZ3 Data.Expression.VarF
instance Data.Expression.Z3.IToZ3 Data.Expression.ConjunctionF
instance Data.Expression.Z3.IToZ3 Data.Expression.DisjunctionF
instance Data.Expression.Z3.IToZ3 Data.Expression.NegationF
instance Data.Expression.Z3.IToZ3 (Data.Expression.UniversalF v)
instance Data.Expression.Z3.IToZ3 (Data.Expression.ExistentialF v)
instance Data.Expression.Z3.IToZ3 Data.Expression.Equality.EqualityF
instance Data.Expression.Z3.IToZ3 Data.Expression.Arithmetic.ArithmeticF
instance Data.Expression.Z3.IToZ3 Data.Expression.IfThenElse.IfThenElseF
instance Data.Expression.Z3.IToZ3 Data.Expression.Array.ArrayF
instance (Data.Expression.Z3.IToZ3 f, Data.Expression.Z3.IToZ3 g) => Data.Expression.Z3.IToZ3 (f Data.Expression.Utils.Indexed.Sum.:+: g)
instance Z3.Monad.MonadZ3 z3 => Z3.Monad.MonadZ3 (Data.Expression.Z3.Decoder f z3)
